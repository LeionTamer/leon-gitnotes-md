# Generics

In TypeScript generics, extends acts like a gatekeeper. It tells the compiler: "I will accept any type T, but only if it looks at least like this other type."

```ts
type MyGeneric<T extends ConstraintType> = T;
type MustHaveId<T extends { id: string }> = T;
```

You have unlocked a major part of TypeScript safety. By writing K extends keyof T, you are telling the compiler: "K must be one of the keys found in T."

```ts
function getProp<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]; // Safe! TypeScript knows 'key' exists on 'obj'
}
```

Take every key from T, keep the same name, but set the type to boolean

```ts
type OptionsFlags<T> = {
  [K in keyof T]: boolean;
};
```

## Example

Given the interface 

```ts
type User = { id: string; name: string };
type Product = { id: number; price: number };
type Message = { text: string }; // No id here!
```

How would you write the ExtractId<T> type definition to achieve the following results?

```ts
type A = ExtractId<User>;    // Should result in: string
type B = ExtractId<Product>; // Should result in: number
type C = ExtractId<Message>; // Should result in: never
```

```ts
// We must declare <T> here ðŸ‘‡
type ExtractId<T> = T extends { id: string | number }
  ? T['id']   // Return the type of the id
  : never;    // Ignore if no id exists
```

# Infer keyword

The infer keyword allows you to declare a temporary type variable inside the extends clause to "capture" a type

```ts
type GetPromiseValueType<T> = T extends Promise<infer U> ? U : never;

// Example
type ExamplePromise = Promise<number>;
type ValueTypeOfExamplePromise = GetPromiseValueType<ExamplePromise>; // number
```

```ts
type GetParameters<T> = T extends (...args: infer P) => any ? P : never;

type ExampleFunction = (a: number, b: string) => void;
type Params = GetParameters<ExampleFunction>; // [number, string]
```

# Template Literals

```ts
type HandlerNames<T extends string> = `on${Capitalize<T>}`;

// Usage
type T1 = HandlerNames<"click" | "focus">;
// Result: "onClick" | "onFocus"
```

# Mapped Type

```ts
type EventName = "click" | "focus";

type ObjectHandlers = {
  [K in EventName as `on${Capitalize<K>}`]: (e: any) => void
};

/*
Resulting Type:
{
  onClick: (e: any) => void;
  onFocus: (e: any) => void;
}
*/
```